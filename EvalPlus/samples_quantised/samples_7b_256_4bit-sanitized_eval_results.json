{"date": "2024-05-28 02:52", "hash": "84f4b93a1270b492e4c54d5212da7a5b", "eval": {"HumanEval/0": [{"task_id": "HumanEval/0", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/2": [{"task_id": "HumanEval/2", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/1": [{"task_id": "HumanEval/1", "solution": "from python.reverse_words import reverse_words", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/3": [{"task_id": "HumanEval/3", "solution": "from typing import List", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/4": [{"task_id": "HumanEval/4", "solution": "from typing import Optional, Any", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/5": [{"task_id": "HumanEval/5", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/7": [{"task_id": "HumanEval/7", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/11": [{"task_id": "HumanEval/11", "solution": "from typing import List", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/8": [{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/9": [{"task_id": "HumanEval/9", "solution": "from typing import List, Tuple", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/10": [{"task_id": "HumanEval/10", "solution": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n#    print(string)\n    if is_palindrome(string):\n        return string\n    # Find the longest palindromic suffix\n    suffix = ''\n    for i in range(len(string), 0, -1):\n        if is_palindrome(string[:i]):\n            suffix = string[:i]\n            break\n    # Find the longest prefix that comes before the palindromic suffix\n    prefix = ''\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            prefix = string[i:]\n            break\n    # Return the palindrome\n    return prefix + suffix[::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["xyz"]], "plus_fail_tests": []}], "HumanEval/12": [{"task_id": "HumanEval/12", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/13": [{"task_id": "HumanEval/13", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/6": [{"task_id": "HumanEval/6", "solution": "import unittest\nfrom python.nested_parens import parse_nested_parens", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/14": [{"task_id": "HumanEval/14", "solution": "from typing import List", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/23": [{"task_id": "HumanEval/23", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/16": [{"task_id": "HumanEval/16", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/18": [{"task_id": "HumanEval/18", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/30": [{"task_id": "HumanEval/30", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/21": [{"task_id": "HumanEval/21", "solution": "from typing import List", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/48": [{"task_id": "HumanEval/48", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/46": [{"task_id": "HumanEval/46", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/22": [{"task_id": "HumanEval/22", "solution": "from typing import List, Any", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/28": [{"task_id": "HumanEval/28", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/26": [{"task_id": "HumanEval/26", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/39": [{"task_id": "HumanEval/39", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/45": [{"task_id": "HumanEval/45", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/38": [{"task_id": "HumanEval/38", "solution": "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n#     split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[2:] + group[1:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/19": [{"task_id": "HumanEval/19", "solution": "from typing import List\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n\n#    numbers = numbers.split()\n#    numbers.sort()\n#    return''.join(numbers)\n\n    return''.join(sorted(numbers.split()))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["three five nine"]], "plus_fail_tests": []}], "HumanEval/47": [{"task_id": "HumanEval/47", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/44": [{"task_id": "HumanEval/44", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/41": [{"task_id": "HumanEval/41", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/36": [{"task_id": "HumanEval/36", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/42": [{"task_id": "HumanEval/42", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/27": [{"task_id": "HumanEval/27", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/34": [{"task_id": "HumanEval/34", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/43": [{"task_id": "HumanEval/43", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/20": [{"task_id": "HumanEval/20", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/32": [{"task_id": "HumanEval/32", "solution": "import math\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x) = 0.\n    find_zero returns only only zero point, even if there are many.\n    Moreover, find_zero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n#    assert len(xs) % 2 == 0, \"xs must have even number of coefficients\"\n#    assert xs[-1]!= 0, \"xs must have non zero largest coefficient\"\n    return -xs[-2] / (2 * xs[-1])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/24": [{"task_id": "HumanEval/24", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/61": [{"task_id": "HumanEval/61", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/25": [{"task_id": "HumanEval/25", "solution": "from typing import List", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/69": [{"task_id": "HumanEval/69", "solution": "def search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n    for i in range(len(lst)):\n        if lst.count(lst[i]) >= lst[i]:\n            return lst[i]\n    return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]]], "plus_fail_tests": [[[1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5]]]}], "HumanEval/66": [{"task_id": "HumanEval/66", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/51": [{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiou'\n    new_text = ''\n    for char in text:\n        if char not in vowels:\n            new_text += char\n    return new_text", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["acBAA"]], "plus_fail_tests": [["AEIOUaeiouq"]]}], "HumanEval/54": [{"task_id": "HumanEval/54", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/64": [{"task_id": "HumanEval/64", "solution": "FIX = \"\"\"\nAdd more test cases.\n\"\"\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/53": [{"task_id": "HumanEval/53", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/62": [{"task_id": "HumanEval/62", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/37": [{"task_id": "HumanEval/37", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/33": [{"task_id": "HumanEval/33", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/17": [{"task_id": "HumanEval/17", "solution": "from typing import List", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/29": [{"task_id": "HumanEval/29", "solution": "from typing import List", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/59": [{"task_id": "HumanEval/59", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/60": [{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n - 1)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000]]}], "HumanEval/40": [{"task_id": "HumanEval/40", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/31": [{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n == 1:\n        return False\n    elif n == 2:\n        return True\n    else:\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n        return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/35": [{"task_id": "HumanEval/35", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/52": [{"task_id": "HumanEval/52", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/74": [{"task_id": "HumanEval/74", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/70": [{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return lst\n    min_val = min(lst)\n    max_val = max(lst)\n    min_val_index = lst.index(min_val)\n    max_val_index = lst.index(max_val)\n    if min_val_index > max_val_index:\n        lst[min_val_index], lst[max_val_index] = lst[max_val_index], lst[min_val_index]\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/71": [{"task_id": "HumanEval/71", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/65": [{"task_id": "HumanEval/65", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/15": [{"task_id": "HumanEval/15", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/68": [{"task_id": "HumanEval/68", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/50": [{"task_id": "HumanEval/50", "solution": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n#    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/72": [{"task_id": "HumanEval/72", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/76": [{"task_id": "HumanEval/76", "solution": "def is_simple_power(x, n):\n    if x == 1:\n        return True\n    if x == 0:\n        return False\n    if x < 0:\n        return False\n    if n < 0:\n        return False\n    if x == n:\n        return True\n    if x < n:\n        return False\n    if x % n == 0:\n        return is_simple_power(x / n, n)\n    return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[82, 1]]}], "HumanEval/55": [{"task_id": "HumanEval/55", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/56": [{"task_id": "HumanEval/56", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/96": [{"task_id": "HumanEval/96", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/75": [{"task_id": "HumanEval/75", "solution": "def is_multiply_prime(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n    if a < 100:\n        for i in range(2, a):\n            if a % i == 0:\n                return False\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[99]]}], "HumanEval/57": [{"task_id": "HumanEval/57", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/58": [{"task_id": "HumanEval/58", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/93": [{"task_id": "HumanEval/93", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/78": [{"task_id": "HumanEval/78", "solution": "def is_prime(num):\n    \"\"\"\n    Returns True if num is prime, False otherwise.\n    \"\"\"\n    if num < 2:\n        return False\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\ndef count_hex_primes(num):\n    \"\"\"\n    Returns the number of hexadecimal digits that are primes.\n    \"\"\"\n    count = 0\n    for char in num:\n        if is_prime(int(char, 16)):\n            count += 1\n    return count\ndef hex_key(num):\n    return count_hex_primes(num)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/81": [{"task_id": "HumanEval/81", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/83": [{"task_id": "HumanEval/83", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/77": [{"task_id": "HumanEval/77", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/84": [{"task_id": "HumanEval/84", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/63": [{"task_id": "HumanEval/63", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/79": [{"task_id": "HumanEval/79", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/90": [{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    lst.sort()\n    return lst[1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1]]], "plus_fail_tests": [[[2, 2, 2, 2, 2, 2, 3, 3, 3, 3]]]}], "HumanEval/73": [{"task_id": "HumanEval/73", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/91": [{"task_id": "HumanEval/91", "solution": "def is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    return S.count('I')", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Is the sky blue?"]], "plus_fail_tests": [["I forgot my phone in the car. Oh no, now I have to go back and get it."]]}], "HumanEval/85": [{"task_id": "HumanEval/85", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/87": [{"task_id": "HumanEval/87", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/80": [{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    return len(s) >= 3 and len(set(s[i:i+3]) for i in range(len(s)-2)) == len(s)-2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["abcd"]], "plus_fail_tests": []}], "HumanEval/82": [{"task_id": "HumanEval/82", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/103": [{"task_id": "HumanEval/103", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/98": [{"task_id": "HumanEval/98", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/92": [{"task_id": "HumanEval/92", "solution": "int(x, y, z):\n    return (x + y == z) and (x, y, z).is_integer()\n\ndef an", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/88": [{"task_id": "HumanEval/88", "solution": "def sort_array(array):\n    if len(array) == 0:\n        return []\n    if len(array) == 1:\n        return array\n    if len(array) == 2:\n        if array[0] > array[1]:\n            return array[::-1]\n        else:\n            return array\n    if len(array) > 2:\n        if (array[0] + array[-1]) % 2 == 0:\n            return array[::-1]\n        else:\n            return array", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 4, 3, 0, 1, 5]]], "plus_fail_tests": [[[4, 3, 2, 1]]]}], "HumanEval/86": [{"task_id": "HumanEval/86", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/67": [{"task_id": "HumanEval/67", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/97": [{"task_id": "HumanEval/97", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/105": [{"task_id": "HumanEval/105", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/109": [{"task_id": "HumanEval/109", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/99": [{"task_id": "HumanEval/99", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/102": [{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n    if x > y:\n        return -1\n    if x % 2 == 0:\n        x = x\n    else:\n        x = x + 1\n    if y % 2 == 0:\n        y = y\n    else:\n        y = y - 1\n    if x > y:\n        return -1\n    else:\n        return y", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/95": [{"task_id": "HumanEval/95", "solution": "def check_dict_case(dict):\n    if dict == {}:\n        return False\n    else:\n        for key in dict:\n            if key.islower() == True:\n                return True\n            else:\n                return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"p": "pineapple", "A": "banana", "B": "banana"}]], "plus_fail_tests": []}], "HumanEval/118": [{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    vowels = \"aeiou\"\n    word = word.lower()\n    for i in range(len(word)-1, -1, -1):\n        if word[i] in vowels:\n            for j in range(i-1, -1, -1):\n                if word[j] not in vowels:\n                    return word[i]\n    return \"\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["ali"]], "plus_fail_tests": []}], "HumanEval/89": [{"task_id": "HumanEval/89", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/106": [{"task_id": "HumanEval/106", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/100": [{"task_id": "HumanEval/100", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/114": [{"task_id": "HumanEval/114", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/111": [{"task_id": "HumanEval/111", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/108": [{"task_id": "HumanEval/108", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/110": [{"task_id": "HumanEval/110", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/94": [{"task_id": "HumanEval/94", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/113": [{"task_id": "HumanEval/113", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/122": [{"task_id": "HumanEval/122", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/121": [{"task_id": "HumanEval/121", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/123": [{"task_id": "HumanEval/123", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/117": [{"task_id": "HumanEval/117", "solution": "def select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n    words = s.split()\n    result = []\n    for word in words:\n        if count_consonants(word) == n:\n            result.append(word)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/101": [{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    return s.split()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/120": [{"task_id": "HumanEval/120", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/115": [{"task_id": "HumanEval/115", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/112": [{"task_id": "HumanEval/112", "solution": "def reverse_delete(s,c):\n    return (s.translate(str.maketrans(c,\"\"*len(c))),s==s[::-1])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/107": [{"task_id": "HumanEval/107", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/129": [{"task_id": "HumanEval/129", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/104": [{"task_id": "HumanEval/104", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/125": [{"task_id": "HumanEval/125", "solution": "split_words(txt):\n    return txt.split() if'' in txt else txt.split(',') if ',' in txt else len(txt)\n\nde", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/127": [{"task_id": "HumanEval/127", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/124": [{"task_id": "HumanEval/124", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/126": [{"task_id": "HumanEval/126", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/116": [{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/128": [{"task_id": "HumanEval/128", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/119": [{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    return 'Yes' if len(lst) == 2 and lst[0][-1] == lst[1][0] else 'No'", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/133": [{"task_id": "HumanEval/133", "solution": "def sum_squares(lst):\n    return sum([int(math.ceil(x**2)) for x in lst])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/132": [{"task_id": "HumanEval/132", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/147": [{"task_id": "HumanEval/147", "solution": "get_max_triples(n):\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n    if n < 3:\n        return 0\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/137": [{"task_id": "HumanEval/137", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/135": [{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n    for i in range(len(arr)-1):\n        if arr[i] >= arr[i+1]:\n            return i\n    return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 4, 3, 2, 1]]]}], "HumanEval/131": [{"task_id": "HumanEval/131", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/138": [{"task_id": "HumanEval/138", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/136": [{"task_id": "HumanEval/136", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/144": [{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n    x_num, x_den = x.split(\"/\")\n    n_num, n_den = n.split(\"/\")\n    x_num = int(x_num)\n    x_den = int(x_den)\n    n_num = int(n_num)\n    n_den = int(n_den)\n    if x_num * n_num == x_den * n_den:\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["5/1", "3/1"]], "plus_fail_tests": [["616/6", "6/1"]]}], "HumanEval/154": [{"task_id": "HumanEval/154", "solution": "def cycpattern_check(a, b):\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"\n    return b in a or b in a[1:] or b in a[2:] or b in a[3:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["efef", "fee"]], "plus_fail_tests": [["coffee", "ffeco"]]}], "HumanEval/139": [{"task_id": "HumanEval/139", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/163": [{"task_id": "HumanEval/163", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/159": [{"task_id": "HumanEval/159", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/145": [{"task_id": "HumanEval/145", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/134": [{"task_id": "HumanEval/134", "solution": "k_if_last_char_is_a_letter(txt):\n    return txt[-1].isalpha() and not txt[-1].isspace()\n\nprint(", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/151": [{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    return sum([x**2 for x in lst if x > 0 and x % 2 == 1])", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1.0, 3.5, -4.6]]]}], "HumanEval/153": [{"task_id": "HumanEval/153", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/150": [{"task_id": "HumanEval/150", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/141": [{"task_id": "HumanEval/141", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/143": [{"task_id": "HumanEval/143", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/148": [{"task_id": "HumanEval/148", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/149": [{"task_id": "HumanEval/149", "solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted(lst, key=lambda x: (len(x), x))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/158": [{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    \"\"\"Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\",\"cc\"]) == \"\"aaaaaaa\"\n    \"\"\"\n    max_word = \"\"\n    max_unique_chars = 0\n    for word in words:\n        if len(set(word)) > max_unique_chars:\n            max_unique_chars = len(set(word))\n            max_word = word\n    return max_word", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["name", "enam", "game"]]], "plus_fail_tests": [[["xyz", "pqr"]]]}], "HumanEval/140": [{"task_id": "HumanEval/140", "solution": "def fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n    return text.replace(\" \", \"_\").replace(\"  \", \"-\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["Exa   mple"]], "plus_fail_tests": []}], "HumanEval/155": [{"task_id": "HumanEval/155", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/146": [{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    \"\"\"Write a function that takes an array of numbers as input and returns \n    the number of elements in the array that are greater than 10 and both \n    first and last digits of a number are odd (1, 3, 5, 7, 9).\n    For example:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"\n    count = 0\n    for num in nums:\n        if num > 10 and num % 10 in [1, 3, 5, 7, 9]:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[33, -2, -3, 45, 21, 109]]], "plus_fail_tests": [[[6, 89, -12, 77, 13, 196]]]}], "HumanEval/160": [{"task_id": "HumanEval/160", "solution": "def do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n    # Your code here\n    return 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/152": [{"task_id": "HumanEval/152", "solution": "def compare(game,guess):\n    return [abs(g-s) for g,s in zip(game,guess)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/142": [{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    \"\"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/156": [{"task_id": "HumanEval/156", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/157": [{"task_id": "HumanEval/157", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/161": [{"task_id": "HumanEval/161", "solution": "def solve(s):\n    \"\"\"You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n    return ''.join([c.swapcase() if c.isalpha() else c for c in s])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["1234"]], "plus_fail_tests": [["!!!!1234!!!!"]]}], "HumanEval/162": [{"task_id": "HumanEval/162", "solution": "", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/49": [{"task_id": "HumanEval/49", "solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n#    return pow(2, n, p)\n    return 2**n % p", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "HumanEval/130": [{"task_id": "HumanEval/130", "solution": "def tri(n):\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"\n    if n == 0:\n        return [1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}]}}